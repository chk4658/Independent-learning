<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script type="text/javascript">
		// 函数 可以封装一段特定功能的代码,可以重复调用
		// 函数的调用
		function getSum() {
			var sum = 0;
			for(var i = 0;i <= 100;i++){
				sum += i;
			}
			console.log(sum);
		}
		// 调用函数
		getSum();

		// 有参数
		function fun(num1,num2){
			console.log(num1+num2);
		}
		fun(21,56);

		// 返回值
		function fun2(num3,num4){
			return num3+num4;
		}
		console.log(fun2(3,4))
		// 没有return的时候，返回的是undenfined
		// return后面的代码不执行
		// return;返回的是undefined

		/*arguments对象是比较特别的一个对象，实际上是当前函数的一个内置属性
		它存储了传递的所有实参，它是一个伪数组*/
		function fun3(){
			console.log(arguments);
			console.log(1);
		}
		fun3(21,56);
		// 实参个数不确定的时候，就可以使用arguments


		// 斐波那契数列js实现
		function fun4 (n) {
			var n1 = 1;
			var n2 = 1;
			var n3;
			for (var i = 3; i <=n; i++) {
				n3 = n1 + n2;
				n1 = n2;
				n2 = n3;
			}
			return n3;
		}
		console.log(fun4(6));

		// 数组的反转
		function fun5(array) {
			var newArray = [];
			for (var i = array.length - 1; i >= 0; i--) {
				newArray[newArray.length] = array[i];
			}
			return newArray;
		}
		var arr = [7,4,66,45];
		console.log(fun5(arr));

		//1、函数声明  命名函数 2、函数表达式  3、自调用函数  4、函数也是一种数据类型
		// 2、函数表达式
		var fn = function() {
		}
        // 3、自调用函数  当函数书写完成之后立即调用
        /*(function(){
        	console.log('自调用函数');
        })()*/
        // 4、函数也是一种数据类型
        console.log(typeof fn);/*function*/

        // 作用域
        /*全局作用域：在script或者一个独立的js文件中，在全局作用域中定义的变量是全局变量，在任何位置都可以使用*/
        /*局部作用域：任何一个函数的内部都有一个局部作用域，在局部作用域中定义的变量叫局部变量，局部变量只有在定义该变量的函数中可以访问*/
        // 块级作用域


        /*预解析
        1、变量提升，把变量的声明提升到当前作用域的最上面，不包括变量的赋值
        2、函数提升，把函数的声明提升到当前作用域的最上面，不包括函数的调用*/
	</script>
</head>
<body>
	
</body>
</html>